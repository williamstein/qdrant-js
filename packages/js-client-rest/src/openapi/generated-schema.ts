/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/telemetry": {
    /**
     * Collect telemetry data 
     * @description Collect telemetry data including app info, system info, collections info, cluster info, configs and statistics
     */
    get: operations["telemetry"];
  };
  "/metrics": {
    /**
     * Collect Prometheus metrics data 
     * @description Collect metrics data including app info, collections info, cluster info and statistics
     */
    get: operations["metrics"];
  };
  "/locks": {
    /**
     * Get lock options 
     * @description Get lock options. If write is locked, all write operations and collection creation are forbidden
     */
    get: operations["get_locks"];
    /**
     * Set lock options 
     * @description Set lock options. If write is locked, all write operations and collection creation are forbidden. Returns previous lock options
     */
    post: operations["post_locks"];
  };
  "/cluster": {
    /**
     * Get cluster status info 
     * @description Get information about the current state and composition of the cluster
     */
    get: operations["cluster_status"];
  };
  "/cluster/recover": {
    /** Tries to recover current peer Raft state. */
    post: operations["recover_current_peer"];
  };
  "/cluster/peer/{peer_id}": {
    /**
     * Remove peer from the cluster 
     * @description Tries to remove peer from the cluster. Will return an error if peer has shards on it.
     */
    delete: operations["remove_peer"];
  };
  "/collections": {
    /**
     * List collections 
     * @description Get list name of all existing collections
     */
    get: operations["get_collections"];
  };
  "/collections/{collection_name}": {
    /**
     * Collection info 
     * @description Get detailed information about specified existing collection
     */
    get: operations["get_collection"];
    /**
     * Create collection 
     * @description Create new collection with given parameters
     */
    put: operations["create_collection"];
    /**
     * Delete collection 
     * @description Drop collection and all associated data
     */
    delete: operations["delete_collection"];
    /**
     * Update collection parameters 
     * @description Update parameters of the existing collection
     */
    patch: operations["update_collection"];
  };
  "/collections/aliases": {
    /** Update aliases of the collections */
    post: operations["update_aliases"];
  };
  "/collections/{collection_name}/index": {
    /**
     * Create index for field in collection 
     * @description Create index for field in collection
     */
    put: operations["create_field_index"];
  };
  "/collections/{collection_name}/index/{field_name}": {
    /**
     * Delete index for field in collection 
     * @description Delete field index for collection
     */
    delete: operations["delete_field_index"];
  };
  "/collections/{collection_name}/cluster": {
    /**
     * Collection cluster info 
     * @description Get cluster information for a collection
     */
    get: operations["collection_cluster_info"];
    /** Update collection cluster setup */
    post: operations["update_collection_cluster"];
  };
  "/collections/{collection_name}/aliases": {
    /**
     * List aliases for collection 
     * @description Get list of all aliases for a collection
     */
    get: operations["get_collection_aliases"];
  };
  "/aliases": {
    /**
     * List collections aliases 
     * @description Get list of all existing collections aliases
     */
    get: operations["get_collections_aliases"];
  };
  "/collections/{collection_name}/snapshots/upload": {
    /**
     * Recover from an uploaded snapshot 
     * @description Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
     */
    post: operations["recover_from_uploaded_snapshot"];
  };
  "/collections/{collection_name}/snapshots/recover": {
    /**
     * Recover from a snapshot 
     * @description Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
     */
    put: operations["recover_from_snapshot"];
  };
  "/collections/{collection_name}/snapshots": {
    /**
     * List collection snapshots 
     * @description Get list of snapshots for a collection
     */
    get: operations["list_snapshots"];
    /**
     * Create collection snapshot 
     * @description Create new snapshot for a collection
     */
    post: operations["create_snapshot"];
  };
  "/collections/{collection_name}/snapshots/{snapshot_name}": {
    /**
     * Download collection snapshot 
     * @description Download specified snapshot from a collection as a file
     */
    get: operations["get_snapshot"];
    /**
     * Delete collection snapshot 
     * @description Delete snapshot for a collection
     */
    delete: operations["delete_snapshot"];
  };
  "/snapshots": {
    /**
     * List of storage snapshots 
     * @description Get list of snapshots of the whole storage
     */
    get: operations["list_full_snapshots"];
    /**
     * Create storage snapshot 
     * @description Create new snapshot of the whole storage
     */
    post: operations["create_full_snapshot"];
  };
  "/snapshots/{snapshot_name}": {
    /**
     * Download storage snapshot 
     * @description Download specified snapshot of the whole storage as a file
     */
    get: operations["get_full_snapshot"];
    /**
     * Delete storage snapshot 
     * @description Delete snapshot of the whole storage
     */
    delete: operations["delete_full_snapshot"];
  };
  "/collections/{collection_name}/points/{id}": {
    /**
     * Get point 
     * @description Retrieve full information of single point by id
     */
    get: operations["get_point"];
  };
  "/collections/{collection_name}/points": {
    /**
     * Upsert points 
     * @description Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
     */
    put: operations["upsert_points"];
    /**
     * Get points 
     * @description Retrieve multiple points by specified IDs
     */
    post: operations["get_points"];
  };
  "/collections/{collection_name}/points/delete": {
    /**
     * Delete points 
     * @description Delete points
     */
    post: operations["delete_points"];
  };
  "/collections/{collection_name}/points/payload": {
    /**
     * Overwrite payload 
     * @description Replace full payload of points with new one
     */
    put: operations["overwrite_payload"];
    /**
     * Set payload 
     * @description Set payload values for points
     */
    post: operations["set_payload"];
  };
  "/collections/{collection_name}/points/payload/delete": {
    /**
     * Delete payload 
     * @description Delete specified key payload for points
     */
    post: operations["delete_payload"];
  };
  "/collections/{collection_name}/points/payload/clear": {
    /**
     * Clear payload 
     * @description Remove all payload for specified points
     */
    post: operations["clear_payload"];
  };
  "/collections/{collection_name}/points/scroll": {
    /**
     * Scroll points 
     * @description Scroll request - paginate over all points which matches given filtering condition
     */
    post: operations["scroll_points"];
  };
  "/collections/{collection_name}/points/search": {
    /**
     * Search points 
     * @description Retrieve closest points based on vector similarity and given filtering conditions
     */
    post: operations["search_points"];
  };
  "/collections/{collection_name}/points/search/batch": {
    /**
     * Search batch points 
     * @description Retrieve by batch the closest points based on vector similarity and given filtering conditions
     */
    post: operations["search_batch_points"];
  };
  "/collections/{collection_name}/points/recommend": {
    /**
     * Recommend points 
     * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples.
     */
    post: operations["recommend_points"];
  };
  "/collections/{collection_name}/points/recommend/batch": {
    /**
     * Recommend batch points 
     * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples.
     */
    post: operations["recommend_batch_points"];
  };
  "/collections/{collection_name}/points/count": {
    /**
     * Count points 
     * @description Count points which matches given filtering condition
     */
    post: operations["count_points"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    ErrorResponse: {
      /**
       * Format: float 
       * @description Time spent to process this request
       */
      time?: number;
      status?: {
        /** @description Description of the occurred error. */
        error?: string;
      };
      result?: Record<string, unknown> | null;
    };
    CollectionsResponse: {
      collections: (components["schemas"]["CollectionDescription"])[];
    };
    CollectionDescription: {
      name: string;
    };
    /** @description Current statistics and configuration of the collection */
    CollectionInfo: {
      status: components["schemas"]["CollectionStatus"];
      optimizerStatus: components["schemas"]["OptimizersStatus"];
      /**
       * Format: uint 
       * @description Number of vectors in collection All vectors in collection are available for querying Calculated as `points_count x vectors_per_point` Where `vectors_per_point` is a number of named vectors in schema
       */
      vectorsCount: number;
      /**
       * Format: uint 
       * @description Number of indexed vectors in the collection. Indexed vectors in large segments are faster to query, as it is stored in vector index (HNSW)
       */
      indexedVectorsCount: number;
      /**
       * Format: uint 
       * @description Number of points (vectors + payloads) in collection Each point could be accessed by unique id
       */
      pointsCount: number;
      /**
       * Format: uint 
       * @description Number of segments in collection. Each segment has independent vector as payload indexes
       */
      segmentsCount: number;
      config: components["schemas"]["CollectionConfig"];
      /** @description Types of stored payload */
      payloadSchema: {
        [key: string]: components["schemas"]["PayloadIndexInfo"] | undefined;
      };
    };
    /**
     * @description Current state of the collection. `Green` - all good. `Yellow` - optimization is running, `Red` - some operations failed and was not recovered 
     * @enum {string}
     */
    CollectionStatus: "green" | "yellow" | "red";
    /** @description Current state of the collection */
    OptimizersStatus: OneOf<["ok", {
      error: string;
    }]>;
    CollectionConfig: {
      params: components["schemas"]["CollectionParams"];
      hnswConfig: components["schemas"]["HnswConfig"];
      optimizerConfig: components["schemas"]["OptimizersConfig"];
      walConfig: components["schemas"]["WalConfig"];
      /** @default null */
      quantizationConfig?: components["schemas"]["QuantizationConfig"] | (Record<string, unknown> | null);
    };
    CollectionParams: {
      vectors: components["schemas"]["VectorsConfig"];
      /**
       * Format: uint32 
       * @description Number of shards the collection has 
       * @default 1
       */
      shardNumber?: number;
      /**
       * Format: uint32 
       * @description Number of replicas for each shard 
       * @default 1
       */
      replicationFactor?: number;
      /**
       * Format: uint32 
       * @description Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact. 
       * @default 1
       */
      writeConsistencyFactor?: number;
      /**
       * @description If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM. 
       * @default false
       */
      onDiskPayload?: boolean;
    };
    /**
     * @description Vector params separator for single and multiple vector modes Single mode:
     * 
     * { "size": 128, "distance": "Cosine" }
     * 
     * or multiple mode:
     * 
     * { "default": { "size": 128, "distance": "Cosine" } }
     */
    VectorsConfig: components["schemas"]["VectorParams"] | ({
      [key: string]: components["schemas"]["VectorParams"] | undefined;
    });
    /** @description Params of single vector data storage */
    VectorParams: {
      /**
       * Format: uint64 
       * @description Size of a vectors used
       */
      size: number;
      distance: components["schemas"]["Distance"];
      /** @description Custom params for HNSW index. If none - values from collection configuration are used. */
      hnswConfig?: components["schemas"]["HnswConfigDiff"] | (Record<string, unknown> | null);
      /** @description Custom params for quantization. If none - values from collection configuration are used. */
      quantizationConfig?: components["schemas"]["QuantizationConfig"] | (Record<string, unknown> | null);
    };
    /**
     * @description Type of internal tags, build from payload Distance function types used to compare vectors 
     * @enum {string}
     */
    Distance: "Cosine" | "Euclid" | "Dot";
    HnswConfigDiff: {
      /**
       * Format: uint 
       * @description Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
       */
      m?: number | null;
      /**
       * Format: uint 
       * @description Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build the index.
       */
      efConstruct?: number | null;
      /**
       * Format: uint 
       * @description Minimal size (in KiloBytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256
       */
      fullScanThreshold?: number | null;
      /**
       * Format: uint 
       * @description Number of parallel threads used for background index building. If 0 - auto selection.
       */
      maxIndexingThreads?: number | null;
      /** @description Store HNSW index on disk. If set to false, the index will be stored in RAM. Default: false */
      onDisk?: boolean | null;
      /**
       * Format: uint 
       * @description Custom M param for additional payload-aware HNSW links. If not set, default M will be used.
       */
      payloadM?: number | null;
    };
    QuantizationConfig: components["schemas"]["ScalarQuantization"];
    ScalarQuantization: {
      scalar: components["schemas"]["ScalarQuantizationConfig"];
    };
    ScalarQuantizationConfig: {
      type: components["schemas"]["ScalarType"];
      /**
       * Format: float 
       * @description Quantile for quantization. Expected value range in [0.5, 1.0]. If not set - use the whole range of values
       */
      quantile?: number | null;
      /** @description If true - quantized vectors always will be stored in RAM, ignoring the config of main storage */
      alwaysRam?: boolean | null;
    };
    /** @enum {string} */
    ScalarType: "int8";
    /** @description Config of HNSW index */
    HnswConfig: {
      /**
       * Format: uint 
       * @description Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
       */
      m: number;
      /**
       * Format: uint 
       * @description Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.
       */
      efConstruct: number;
      /**
       * Format: uint 
       * @description Minimal size (in KiloBytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won't be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256
       */
      fullScanThreshold: number;
      /**
       * Format: uint 
       * @description Number of parallel threads used for background index building. If 0 - auto selection. 
       * @default 0
       */
      maxIndexingThreads?: number;
      /** @description Store HNSW index on disk. If set to false, index will be stored in RAM. Default: false */
      onDisk?: boolean | null;
      /**
       * Format: uint 
       * @description Custom M param for hnsw graph built for payload index. If not set, default M will be used.
       */
      payloadM?: number | null;
    };
    OptimizersConfig: {
      /**
       * Format: double 
       * @description The minimal fraction of deleted vectors in a segment, required to perform segment optimization
       */
      deletedThreshold: number;
      /**
       * Format: uint 
       * @description The minimal number of vectors in a segment, required to perform segment optimization
       */
      vacuumMinVectorNumber: number;
      /**
       * Format: uint 
       * @description Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS
       * 
       * It is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads. If `default_segment_number = 0`, will be automatically selected by the number of available CPUs.
       */
      defaultSegmentNumber: number;
      /**
       * Format: uint 
       * @description Do not create segments larger this size (in KiloBytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.
       * 
       * If indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256 If not set, will be automatically selected considering the number of available CPUs. 
       * @default null
       */
      maxSegmentSize?: number | null;
      /**
       * Format: uint 
       * @description Maximum size (in KiloBytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file. To enable memmap storage, lower the threshold Note: 1Kb = 1 vector of size 256 If not set, mmap will not be used. 
       * @default null
       */
      memmapThreshold?: number | null;
      /**
       * Format: uint 
       * @description Maximum size (in KiloBytes) of vectors allowed for plain index. Default value based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md> Note: 1Kb = 1 vector of size 256
       */
      indexingThreshold: number;
      /**
       * Format: uint64 
       * @description Minimum interval between forced flushes.
       */
      flushIntervalSec: number;
      /**
       * Format: uint 
       * @description Maximum available threads for optimization workers
       */
      maxOptimizationThreads: number;
    };
    WalConfig: {
      /**
       * Format: uint 
       * @description Size of a single WAL segment in MB
       */
      walCapacityMb: number;
      /**
       * Format: uint 
       * @description Number of WAL segments to create ahead of actually used ones
       */
      walSegmentsAhead: number;
    };
    /** @description Display payload field type & index information */
    PayloadIndexInfo: {
      dataType: components["schemas"]["PayloadSchemaType"];
      params?: components["schemas"]["PayloadSchemaParams"] | (Record<string, unknown> | null);
      /**
       * Format: uint 
       * @description Number of points indexed with this index
       */
      points: number;
    };
    /**
     * @description All possible names of payload types 
     * @enum {string}
     */
    PayloadSchemaType: "keyword" | "integer" | "float" | "geo" | "text";
    /** @description Payload type with parameters */
    PayloadSchemaParams: components["schemas"]["TextIndexParams"];
    TextIndexParams: {
      type: components["schemas"]["TextIndexType"];
      tokenizer?: components["schemas"]["TokenizerType"];
      /** Format: uint */
      minTokenLen?: number | null;
      /** Format: uint */
      maxTokenLen?: number | null;
      /** @description If true, lowercase all tokens. Default: true */
      lowercase?: boolean | null;
    };
    /** @enum {string} */
    TextIndexType: "text";
    /** @enum {string} */
    TokenizerType: "prefix" | "whitespace" | "word";
    PointRequest: {
      /** @description Look for points with ids */
      ids: (components["schemas"]["ExtendedPointId"])[];
      /** @description Select which payload to return with the response. Default: All */
      withPayload?: components["schemas"]["WithPayloadInterface"] | (Record<string, unknown> | null);
      withVector?: components["schemas"]["WithVector"];
    };
    /** @description Type, used for specifying point ID in user interface */
    ExtendedPointId: number | string;
    /** @description Options for specifying which payload to include or not */
    WithPayloadInterface: boolean | (string)[] | components["schemas"]["PayloadSelector"];
    /** @description Specifies how to treat payload selector */
    PayloadSelector: components["schemas"]["PayloadSelectorInclude"] | components["schemas"]["PayloadSelectorExclude"];
    PayloadSelectorInclude: {
      /** @description Only include this payload keys */
      include: (string)[];
    };
    PayloadSelectorExclude: {
      /** @description Exclude this fields from returning payload */
      exclude: (string)[];
    };
    /** @description Options for specifying which vector to include */
    WithVector: boolean | (string)[];
    /** @description Point data */
    Record: {
      id: components["schemas"]["ExtendedPointId"];
      /** @description Payload - values assigned to the point */
      payload?: components["schemas"]["Payload"] | (Record<string, unknown> | null);
      /** @description Vector of the point */
      vector?: components["schemas"]["VectorStruct"] | (Record<string, unknown> | null);
    };
    Payload: {
      [key: string]: unknown | undefined;
    };
    /** @description Full vector data per point separator with single and multiple vector modes */
    VectorStruct: (number)[] | ({
      [key: string]: (number)[] | undefined;
    });
    /** @description Search request. Holds all conditions and parameters for the search of most similar points by vector similarity given the filtering restrictions. */
    SearchRequest: {
      vector: components["schemas"]["NamedVectorStruct"];
      /** @description Look only for points which satisfies this conditions */
      filter?: components["schemas"]["Filter"] | (Record<string, unknown> | null);
      /** @description Additional search params */
      params?: components["schemas"]["SearchParams"] | (Record<string, unknown> | null);
      /**
       * Format: uint 
       * @description Max number of result to return
       */
      limit: number;
      /**
       * Format: uint 
       * @description Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues. 
       * @default 0
       */
      offset?: number;
      /** @description Select which payload to return with the response. Default: None */
      withPayload?: components["schemas"]["WithPayloadInterface"] | (Record<string, unknown> | null);
      /**
       * @description Whether to return the point vector with the result? 
       * @default null
       */
      withVector?: components["schemas"]["WithVector"] | (Record<string, unknown> | null);
      /**
       * Format: float 
       * @description Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
       */
      scoreThreshold?: number | null;
    };
    /**
     * @description Vector data separator for named and unnamed modes Unanmed mode:
     * 
     * { "vector": [1.0, 2.0, 3.0] }
     * 
     * or named mode:
     * 
     * { "vector": { "vector": [1.0, 2.0, 3.0], "name": "image-embeddings" } }
     */
    NamedVectorStruct: (number)[] | components["schemas"]["NamedVector"];
    /** @description Vector data with name */
    NamedVector: {
      /** @description Name of vector data */
      name: string;
      /** @description Vector data */
      vector: (number)[];
    };
    Filter: {
      /** @description At least one of those conditions should match */
      should?: (components["schemas"]["Condition"])[] | null;
      /** @description All conditions must match */
      must?: (components["schemas"]["Condition"])[] | null;
      /** @description All conditions must NOT match */
      mustNot?: (components["schemas"]["Condition"])[] | null;
    };
    Condition: components["schemas"]["FieldCondition"] | components["schemas"]["IsEmptyCondition"] | components["schemas"]["IsNullCondition"] | components["schemas"]["HasIdCondition"] | components["schemas"]["Filter"];
    /** @description All possible payload filtering conditions */
    FieldCondition: {
      /** @description Payload key */
      key: string;
      /** @description Check if point has field with a given value */
      match?: components["schemas"]["Match"] | (Record<string, unknown> | null);
      /** @description Check if points value lies in a given range */
      range?: components["schemas"]["Range"] | (Record<string, unknown> | null);
      /** @description Check if points geo location lies in a given area */
      geoBoundingBox?: components["schemas"]["GeoBoundingBox"] | (Record<string, unknown> | null);
      /** @description Check if geo point is within a given radius */
      geoRadius?: components["schemas"]["GeoRadius"] | (Record<string, unknown> | null);
      /** @description Check number of values of the field */
      valuesCount?: components["schemas"]["ValuesCount"] | (Record<string, unknown> | null);
    };
    /** @description Match filter request */
    Match: components["schemas"]["MatchValue"] | components["schemas"]["MatchText"] | components["schemas"]["MatchAny"];
    /** @description Exact match of the given value */
    MatchValue: {
      value: components["schemas"]["ValueVariants"];
    };
    ValueVariants: string | number | boolean;
    /** @description Full-text match of the strings. */
    MatchText: {
      text: string;
    };
    /** @description Exact match on any of the given values */
    MatchAny: {
      any: components["schemas"]["AnyVariants"];
    };
    AnyVariants: (string)[] | (number)[];
    /** @description Range filter request */
    Range: {
      /**
       * Format: double 
       * @description point.key < range.lt
       */
      lt?: number | null;
      /**
       * Format: double 
       * @description point.key > range.gt
       */
      gt?: number | null;
      /**
       * Format: double 
       * @description point.key >= range.gte
       */
      gte?: number | null;
      /**
       * Format: double 
       * @description point.key <= range.lte
       */
      lte?: number | null;
    };
    /**
     * @description Geo filter request
     * 
     * Matches coordinates inside the rectangle, described by coordinates of lop-left and bottom-right edges
     */
    GeoBoundingBox: {
      topLeft: components["schemas"]["GeoPoint"];
      bottomRight: components["schemas"]["GeoPoint"];
    };
    /** @description Geo point payload schema */
    GeoPoint: {
      /** Format: double */
      lon: number;
      /** Format: double */
      lat: number;
    };
    /**
     * @description Geo filter request
     * 
     * Matches coordinates inside the circle of `radius` and center with coordinates `center`
     */
    GeoRadius: {
      center: components["schemas"]["GeoPoint"];
      /**
       * Format: double 
       * @description Radius of the area in meters
       */
      radius: number;
    };
    /** @description Values count filter request */
    ValuesCount: {
      /**
       * Format: uint 
       * @description point.key.length() < values_count.lt
       */
      lt?: number | null;
      /**
       * Format: uint 
       * @description point.key.length() > values_count.gt
       */
      gt?: number | null;
      /**
       * Format: uint 
       * @description point.key.length() >= values_count.gte
       */
      gte?: number | null;
      /**
       * Format: uint 
       * @description point.key.length() <= values_count.lte
       */
      lte?: number | null;
    };
    /** @description Select points with empty payload for a specified field */
    IsEmptyCondition: {
      isEmpty: components["schemas"]["PayloadField"];
    };
    /** @description Payload field */
    PayloadField: {
      /** @description Payload field name */
      key: string;
    };
    /** @description Select points with null payload for a specified field */
    IsNullCondition: {
      isNull: components["schemas"]["PayloadField"];
    };
    /** @description ID-based filtering condition */
    HasIdCondition: {
      hasId: (components["schemas"]["ExtendedPointId"])[];
    };
    /** @description Additional parameters of the search */
    SearchParams: {
      /**
       * Format: uint 
       * @description Params relevant to HNSW index /// Size of the beam in a beam-search. Larger the value - more accurate the result, more time required for search.
       */
      hnswEf?: number | null;
      /**
       * @description Search without approximation. If set to true, search may run long but with exact results. 
       * @default false
       */
      exact?: boolean;
      /**
       * @description Quantization params 
       * @default null
       */
      quantization?: components["schemas"]["QuantizationSearchParams"] | (Record<string, unknown> | null);
    };
    /** @description Additional parameters of the search */
    QuantizationSearchParams: {
      /**
       * @description If true, quantized vectors are ignored. Default is false. 
       * @default false
       */
      ignore?: boolean;
      /**
       * @description If true, use original vectors to re-score top-k results. Might require more time in case if original vectors are stored on disk. Default is false. 
       * @default false
       */
      rescore?: boolean;
    };
    /** @description Search result */
    ScoredPoint: {
      id: components["schemas"]["ExtendedPointId"];
      /**
       * Format: uint64 
       * @description Point version
       */
      version: number;
      /**
       * Format: float 
       * @description Points vector distance to the query vector
       */
      score: number;
      /** @description Payload - values assigned to the point */
      payload?: components["schemas"]["Payload"] | (Record<string, unknown> | null);
      /** @description Vector of the point */
      vector?: components["schemas"]["VectorStruct"] | (Record<string, unknown> | null);
    };
    UpdateResult: {
      /**
       * Format: uint64 
       * @description Sequential number of the operation
       */
      operationId: number;
      status: components["schemas"]["UpdateStatus"];
    };
    /**
     * @description `Acknowledged` - Request is saved to WAL and will be process in a queue. `Completed` - Request is completed, changes are actual. 
     * @enum {string}
     */
    UpdateStatus: "acknowledged" | "completed";
    /**
     * @description Recommendation request. Provides positive and negative examples of the vectors, which are already stored in the collection.
     * 
     * Service should look for the points which are closer to positive examples and at the same time further to negative examples. The concrete way of how to compare negative and positive distances is up to implementation in `segment` crate.
     */
    RecommendRequest: {
      /** @description Look for vectors closest to those */
      positive: (components["schemas"]["ExtendedPointId"])[];
      /**
       * @description Try to avoid vectors like this 
       * @default []
       */
      negative?: (components["schemas"]["ExtendedPointId"])[];
      /** @description Look only for points which satisfies this conditions */
      filter?: components["schemas"]["Filter"] | (Record<string, unknown> | null);
      /** @description Additional search params */
      params?: components["schemas"]["SearchParams"] | (Record<string, unknown> | null);
      /**
       * Format: uint 
       * @description Max number of result to return
       */
      limit: number;
      /**
       * Format: uint 
       * @description Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues. 
       * @default 0
       */
      offset?: number;
      /** @description Select which payload to return with the response. Default: None */
      withPayload?: components["schemas"]["WithPayloadInterface"] | (Record<string, unknown> | null);
      /**
       * @description Whether to return the point vector with the result? 
       * @default null
       */
      withVector?: components["schemas"]["WithVector"] | (Record<string, unknown> | null);
      /**
       * Format: float 
       * @description Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
       */
      scoreThreshold?: number | null;
      /**
       * @description Define which vector to use for recommendation, if not specified - try to use default vector 
       * @default null
       */
      using?: components["schemas"]["UsingVector"] | (Record<string, unknown> | null);
      /**
       * @description The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection 
       * @default null
       */
      lookupFrom?: components["schemas"]["LookupLocation"] | (Record<string, unknown> | null);
    };
    UsingVector: string;
    /** @description Defines a location to use for looking up the vector. Specifies collection and vector field name. */
    LookupLocation: {
      /** @description Name of the collection used for lookup */
      collection: string;
      /**
       * @description Optional name of the vector field within the collection. If not provided, the default vector field will be used. 
       * @default null
       */
      vector?: string | null;
    };
    /** @description Scroll request - paginate over all points which matches given condition */
    ScrollRequest: {
      /** @description Start ID to read points from. */
      offset?: components["schemas"]["ExtendedPointId"] | (Record<string, unknown> | null);
      /**
       * Format: uint 
       * @description Page size. Default: 10
       */
      limit?: number | null;
      /** @description Look only for points which satisfies this conditions. If not provided - all points. */
      filter?: components["schemas"]["Filter"] | (Record<string, unknown> | null);
      /** @description Select which payload to return with the response. Default: All */
      withPayload?: components["schemas"]["WithPayloadInterface"] | (Record<string, unknown> | null);
      withVector?: components["schemas"]["WithVector"];
    };
    /** @description Result of the points read request */
    ScrollResult: {
      /** @description List of retrieved points */
      points: (components["schemas"]["Record"])[];
      /** @description Offset which should be used to retrieve a next page result */
      nextPageOffset?: components["schemas"]["ExtendedPointId"] | (Record<string, unknown> | null);
    };
    /** @description Operation for creating new collection and (optionally) specify index params */
    CreateCollection: {
      vectors: components["schemas"]["VectorsConfig"];
      /**
       * Format: uint32 
       * @description Number of shards in collection. Default is 1 for standalone, otherwise equal to the number of nodes Minimum is 1 
       * @default null
       */
      shardNumber?: number | null;
      /**
       * Format: uint32 
       * @description Number of shards replicas. Default is 1 Minimum is 1 
       * @default null
       */
      replicationFactor?: number | null;
      /**
       * Format: uint32 
       * @description Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact. 
       * @default null
       */
      writeConsistencyFactor?: number | null;
      /**
       * @description If true - point's payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM. 
       * @default null
       */
      onDiskPayload?: boolean | null;
      /** @description Custom params for HNSW index. If none - values from service configuration file are used. */
      hnswConfig?: components["schemas"]["HnswConfigDiff"] | (Record<string, unknown> | null);
      /** @description Custom params for WAL. If none - values from service configuration file are used. */
      walConfig?: components["schemas"]["WalConfigDiff"] | (Record<string, unknown> | null);
      /** @description Custom params for Optimizers.  If none - values from service configuration file are used. */
      optimizersConfig?: components["schemas"]["OptimizersConfigDiff"] | (Record<string, unknown> | null);
      /**
       * @description Specify other collection to copy data from. 
       * @default null
       */
      initFrom?: components["schemas"]["InitFrom"] | (Record<string, unknown> | null);
      /**
       * @description Quantization parameters. If none - quantization is disabled. 
       * @default null
       */
      quantizationConfig?: components["schemas"]["QuantizationConfig"] | (Record<string, unknown> | null);
    };
    WalConfigDiff: {
      /**
       * Format: uint 
       * @description Size of a single WAL segment in MB
       */
      walCapacityMb?: number | null;
      /**
       * Format: uint 
       * @description Number of WAL segments to create ahead of actually used ones
       */
      walSegmentsAhead?: number | null;
    };
    OptimizersConfigDiff: {
      /**
       * Format: double 
       * @description The minimal fraction of deleted vectors in a segment, required to perform segment optimization
       */
      deletedThreshold?: number | null;
      /**
       * Format: uint 
       * @description The minimal number of vectors in a segment, required to perform segment optimization
       */
      vacuumMinVectorNumber?: number | null;
      /**
       * Format: uint 
       * @description Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS
       * 
       * It is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads If `default_segment_number = 0`, will be automatically selected by the number of available CPUs
       */
      defaultSegmentNumber?: number | null;
      /**
       * Format: uint 
       * @description Do not create segments larger this size (in KiloBytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.
       * 
       * If indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256
       */
      maxSegmentSize?: number | null;
      /**
       * Format: uint 
       * @description Maximum size (in KiloBytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file. To enable memmap storage, lower the threshold Note: 1Kb = 1 vector of size 256
       */
      memmapThreshold?: number | null;
      /**
       * Format: uint 
       * @description Maximum size (in KiloBytes) of vectors allowed for plain index. Default value based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md> Note: 1Kb = 1 vector of size 256
       */
      indexingThreshold?: number | null;
      /**
       * Format: uint64 
       * @description Minimum interval between forced flushes.
       */
      flushIntervalSec?: number | null;
      /**
       * Format: uint 
       * @description Maximum available threads for optimization workers
       */
      maxOptimizationThreads?: number | null;
    };
    /** @description Operation for creating new collection and (optionally) specify index params */
    InitFrom: {
      collection: string;
    };
    /** @description Operation for updating parameters of the existing collection */
    UpdateCollection: {
      /** @description Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete */
      optimizersConfig?: components["schemas"]["OptimizersConfigDiff"] | (Record<string, unknown> | null);
      /** @description Collection base params.  If none - values from service configuration file are used. */
      params?: components["schemas"]["CollectionParamsDiff"] | (Record<string, unknown> | null);
    };
    CollectionParamsDiff: {
      /**
       * Format: uint32 
       * @description Number of replicas for each shard
       */
      replicationFactor?: number | null;
      /**
       * Format: uint32 
       * @description Minimal number successful responses from replicas to consider operation successful
       */
      writeConsistencyFactor?: number | null;
    };
    /** @description Operation for performing changes of collection aliases. Alias changes are atomic, meaning that no collection modifications can happen between alias operations. */
    ChangeAliasesOperation: {
      actions: (components["schemas"]["AliasOperations"])[];
    };
    /** @description Group of all the possible operations related to collection aliases */
    AliasOperations: components["schemas"]["CreateAliasOperation"] | components["schemas"]["DeleteAliasOperation"] | components["schemas"]["RenameAliasOperation"];
    CreateAliasOperation: {
      createAlias: components["schemas"]["CreateAlias"];
    };
    /** @description Create alternative name for a collection. Collection will be available under both names for search, retrieve, */
    CreateAlias: {
      collectionName: string;
      aliasName: string;
    };
    /** @description Delete alias if exists */
    DeleteAliasOperation: {
      deleteAlias: components["schemas"]["DeleteAlias"];
    };
    /** @description Delete alias if exists */
    DeleteAlias: {
      aliasName: string;
    };
    /** @description Change alias to a new one */
    RenameAliasOperation: {
      renameAlias: components["schemas"]["RenameAlias"];
    };
    /** @description Change alias to a new one */
    RenameAlias: {
      oldAliasName: string;
      newAliasName: string;
    };
    CreateFieldIndex: {
      fieldName: string;
      fieldSchema?: components["schemas"]["PayloadFieldSchema"] | (Record<string, unknown> | null);
    };
    PayloadFieldSchema: components["schemas"]["PayloadSchemaType"] | components["schemas"]["PayloadSchemaParams"];
    PointsSelector: components["schemas"]["PointIdsList"] | components["schemas"]["FilterSelector"];
    PointIdsList: {
      points: (components["schemas"]["ExtendedPointId"])[];
    };
    FilterSelector: {
      filter: components["schemas"]["Filter"];
    };
    PointInsertOperations: components["schemas"]["PointsBatch"] | components["schemas"]["PointsList"];
    BatchVectorStruct: ((number)[])[] | ({
      [key: string]: ((number)[])[] | undefined;
    });
    PointStruct: {
      id: components["schemas"]["ExtendedPointId"];
      vector: components["schemas"]["VectorStruct"];
      /** @description Payload values (optional) */
      payload?: components["schemas"]["Payload"] | (Record<string, unknown> | null);
    };
    Batch: {
      ids: (components["schemas"]["ExtendedPointId"])[];
      vectors: components["schemas"]["BatchVectorStruct"];
      payloads?: ((components["schemas"]["Payload"] | (Record<string, unknown> | null))[]) | null;
    };
    PointsBatch: {
      batch: components["schemas"]["Batch"];
    };
    PointsList: {
      points: (components["schemas"]["PointStruct"])[];
    };
    SetPayload: {
      payload: components["schemas"]["Payload"];
      /** @description Assigns payload to each point in this list */
      points?: (components["schemas"]["ExtendedPointId"])[] | null;
      /** @description Assigns payload to each point that satisfy this filter condition */
      filter?: components["schemas"]["Filter"] | (Record<string, unknown> | null);
    };
    DeletePayload: {
      /** @description List of payload keys to remove from payload */
      keys: (string)[];
      /** @description Deletes values from each point in this list */
      points?: (components["schemas"]["ExtendedPointId"])[] | null;
      /** @description Deletes values from points that satisfy this filter condition */
      filter?: components["schemas"]["Filter"] | (Record<string, unknown> | null);
    };
    /** @description Information about current cluster status and structure */
    ClusterStatus: OneOf<[{
      /** @enum {string} */
      status: "disabled";
    }, {
      /** @enum {string} */
      status: "enabled";
      /**
       * Format: uint64 
       * @description ID of this peer
       */
      peerId: number;
      /** @description Peers composition of the cluster with main information */
      peers: {
        [key: string]: components["schemas"]["PeerInfo"] | undefined;
      };
      raftInfo: components["schemas"]["RaftInfo"];
      consensusThreadStatus: components["schemas"]["ConsensusThreadStatus"];
      /** @description Consequent failures of message send operations in consensus by peer address. On the first success to send to that peer - entry is removed from this hashmap. */
      messageSendFailures: {
        [key: string]: components["schemas"]["MessageSendErrors"] | undefined;
      };
    }]>;
    /** @description Information of a peer in the cluster */
    PeerInfo: {
      uri: string;
    };
    /** @description Summary information about the current raft state */
    RaftInfo: {
      /**
       * Format: uint64 
       * @description Raft divides time into terms of arbitrary length, each beginning with an election. If a candidate wins the election, it remains the leader for the rest of the term. The term number increases monotonically. Each server stores the current term number which is also exchanged in every communication.
       */
      term: number;
      /**
       * Format: uint64 
       * @description The index of the latest committed (finalized) operation that this peer is aware of.
       */
      commit: number;
      /**
       * Format: uint 
       * @description Number of consensus operations pending to be applied on this peer
       */
      pendingOperations: number;
      /**
       * Format: uint64 
       * @description Leader of the current term
       */
      leader?: number | null;
      /** @description Role of this peer in the current term */
      role?: components["schemas"]["StateRole"] | (Record<string, unknown> | null);
      /** @description Is this peer a voter or a learner */
      isVoter: boolean;
    };
    /**
     * @description Role of the peer in the consensus 
     * @enum {string}
     */
    StateRole: "Follower" | "Candidate" | "Leader" | "PreCandidate";
    /** @description Information about current consensus thread status */
    ConsensusThreadStatus: OneOf<[{
      /** @enum {string} */
      consensusThreadStatus: "working";
      /** Format: date-time */
      lastUpdate: string;
    }, {
      /** @enum {string} */
      consensusThreadStatus: "stopped";
    }, {
      /** @enum {string} */
      consensusThreadStatus: "stopped_with_err";
      err: string;
    }]>;
    /** @description Message send failures for a particular peer */
    MessageSendErrors: {
      /** Format: uint */
      count: number;
      latestError?: string | null;
    };
    SnapshotDescription: {
      name: string;
      /** Format: partial-date-time */
      creationTime?: string | null;
      /** Format: uint64 */
      size: number;
    };
    /** @description Count Request Counts the number of points which satisfy the given filter. If filter is not provided, the count of all points in the collection will be returned. */
    CountRequest: {
      /** @description Look only for points which satisfies this conditions */
      filter?: components["schemas"]["Filter"] | (Record<string, unknown> | null);
      /**
       * @description If true, count exact number of points. If false, count approximate number of points faster. Approximate count might be unreliable during the indexing process. Default: true 
       * @default true
       */
      exact?: boolean;
    };
    CountResult: {
      /**
       * Format: uint 
       * @description Number of points which satisfy the conditions
       */
      count: number;
    };
    /** @description Current clustering distribution for the collection */
    CollectionClusterInfo: {
      /**
       * Format: uint64 
       * @description ID of this peer
       */
      peerId: number;
      /**
       * Format: uint 
       * @description Total number of shards
       */
      shardCount: number;
      /** @description Local shards */
      localShards: (components["schemas"]["LocalShardInfo"])[];
      /** @description Remote shards */
      remoteShards: (components["schemas"]["RemoteShardInfo"])[];
      /** @description Shard transfers */
      shardTransfers: (components["schemas"]["ShardTransferInfo"])[];
    };
    LocalShardInfo: {
      /**
       * Format: uint32 
       * @description Local shard id
       */
      shardId: number;
      /**
       * Format: uint 
       * @description Number of points in the shard
       */
      pointsCount: number;
      state: components["schemas"]["ReplicaState"];
    };
    /**
     * @description State of the single shard within a replica set. 
     * @enum {string}
     */
    ReplicaState: "Active" | "Dead" | "Partial" | "Initializing" | "Listener";
    RemoteShardInfo: {
      /**
       * Format: uint32 
       * @description Remote shard id
       */
      shardId: number;
      /**
       * Format: uint64 
       * @description Remote peer id
       */
      peerId: number;
      state: components["schemas"]["ReplicaState"];
    };
    ShardTransferInfo: {
      /** Format: uint32 */
      shardId: number;
      /** Format: uint64 */
      from: number;
      /** Format: uint64 */
      to: number;
      /** @description If `true` transfer is a synchronization of a replicas If `false` transfer is a moving of a shard from one peer to another */
      sync: boolean;
    };
    TelemetryData: {
      id: string;
      app: components["schemas"]["AppBuildTelemetry"];
      collections: components["schemas"]["CollectionsTelemetry"];
      cluster: components["schemas"]["ClusterTelemetry"];
      requests: components["schemas"]["RequestsTelemetry"];
    };
    AppBuildTelemetry: {
      name: string;
      version: string;
      features?: components["schemas"]["AppFeaturesTelemetry"] | (Record<string, unknown> | null);
      system?: components["schemas"]["RunningEnvironmentTelemetry"] | (Record<string, unknown> | null);
      /** Format: date-time */
      startup: string;
    };
    AppFeaturesTelemetry: {
      debug: boolean;
      webFeature: boolean;
      serviceDebugFeature: boolean;
    };
    RunningEnvironmentTelemetry: {
      distribution?: string | null;
      distributionVersion?: string | null;
      isDocker: boolean;
      /** Format: uint */
      cores?: number | null;
      /** Format: uint */
      ramSize?: number | null;
      /** Format: uint */
      diskSize?: number | null;
      cpuFlags: string;
    };
    CollectionsTelemetry: {
      /** Format: uint */
      numberOfCollections: number;
      collections?: (components["schemas"]["CollectionTelemetryEnum"])[] | null;
    };
    CollectionTelemetryEnum: components["schemas"]["CollectionTelemetry"] | components["schemas"]["CollectionsAggregatedTelemetry"];
    CollectionTelemetry: {
      id: string;
      /** Format: uint64 */
      initTimeMs: number;
      config: components["schemas"]["CollectionConfig"];
      shards: (components["schemas"]["ReplicaSetTelemetry"])[];
      transfers: (components["schemas"]["ShardTransferInfo"])[];
    };
    ReplicaSetTelemetry: {
      /** Format: uint32 */
      id: number;
      local?: components["schemas"]["LocalShardTelemetry"] | (Record<string, unknown> | null);
      remote: (components["schemas"]["RemoteShardTelemetry"])[];
      replicateStates: {
        [key: string]: components["schemas"]["ReplicaState"] | undefined;
      };
    };
    LocalShardTelemetry: {
      variantName?: string | null;
      segments: (components["schemas"]["SegmentTelemetry"])[];
      optimizations: components["schemas"]["OptimizerTelemetry"];
    };
    SegmentTelemetry: {
      info: components["schemas"]["SegmentInfo"];
      config: components["schemas"]["SegmentConfig"];
      vectorIndexSearches: (components["schemas"]["VectorIndexSearchesTelemetry"])[];
      payloadFieldIndices: (components["schemas"]["PayloadIndexTelemetry"])[];
    };
    /** @description Aggregated information about segment */
    SegmentInfo: {
      segmentType: components["schemas"]["SegmentType"];
      /** Format: uint */
      numVectors: number;
      /** Format: uint */
      numPoints: number;
      /** Format: uint */
      numDeletedVectors: number;
      /** Format: uint */
      ramUsageBytes: number;
      /** Format: uint */
      diskUsageBytes: number;
      isAppendable: boolean;
      indexSchema: {
        [key: string]: components["schemas"]["PayloadIndexInfo"] | undefined;
      };
    };
    /**
     * @description Type of segment 
     * @enum {string}
     */
    SegmentType: "plain" | "indexed" | "special";
    SegmentConfig: {
      vectorData: {
        [key: string]: components["schemas"]["VectorDataConfig"] | undefined;
      };
      index: components["schemas"]["Indexes"];
      storageType: components["schemas"]["StorageType"];
      payloadStorageType?: components["schemas"]["PayloadStorageType"];
      /**
       * @description Quantization parameters. If none - quantization is disabled. 
       * @default null
       */
      quantizationConfig?: components["schemas"]["QuantizationConfig"] | (Record<string, unknown> | null);
    };
    /** @description Config of single vector data storage */
    VectorDataConfig: {
      /**
       * Format: uint 
       * @description Size of a vectors used
       */
      size: number;
      distance: components["schemas"]["Distance"];
      /**
       * @description Vector specific HNSW config that overrides collection config 
       * @default null
       */
      hnswConfig?: components["schemas"]["HnswConfig"] | (Record<string, unknown> | null);
      /**
       * @description Vector specific quantization config that overrides collection config 
       * @default null
       */
      quantizationConfig?: components["schemas"]["QuantizationConfig"] | (Record<string, unknown> | null);
    };
    /** @description Vector index configuration of the segment */
    Indexes: OneOf<[{
      /** @enum {string} */
      type: "plain";
      options: Record<string, never>;
    }, {
      /** @enum {string} */
      type: "hnsw";
      options: components["schemas"]["HnswConfig"];
    }]>;
    /** @description Type of vector storage */
    StorageType: OneOf<[{
      /** @enum {string} */
      type: "in_memory";
    }, {
      /** @enum {string} */
      type: "mmap";
    }]>;
    /** @description Type of payload storage */
    PayloadStorageType: OneOf<[{
      /** @enum {string} */
      type: "in_memory";
    }, {
      /** @enum {string} */
      type: "on_disk";
    }]>;
    VectorIndexSearchesTelemetry: {
      indexName?: string | null;
      unfilteredPlain: components["schemas"]["OperationDurationStatistics"];
      unfilteredHnsw: components["schemas"]["OperationDurationStatistics"];
      filteredPlain: components["schemas"]["OperationDurationStatistics"];
      filteredSmallCardinality: components["schemas"]["OperationDurationStatistics"];
      filteredLargeCardinality: components["schemas"]["OperationDurationStatistics"];
      filteredExact: components["schemas"]["OperationDurationStatistics"];
      unfilteredExact: components["schemas"]["OperationDurationStatistics"];
    };
    OperationDurationStatistics: {
      /** Format: uint */
      count: number;
      /** Format: uint */
      failCount?: number;
      /** Format: float */
      avgDurationMicros?: number | null;
      /** Format: float */
      minDurationMicros?: number | null;
      /** Format: float */
      maxDurationMicros?: number | null;
      /** Format: date-time */
      lastResponded?: string | null;
    };
    PayloadIndexTelemetry: {
      fieldName?: string | null;
      /** Format: uint */
      pointsValuesCount: number;
      /** Format: uint */
      pointsCount: number;
      /** Format: uint */
      histogramBucketSize?: number | null;
    };
    OptimizerTelemetry: {
      status: components["schemas"]["OptimizersStatus"];
      optimizations: components["schemas"]["OperationDurationStatistics"];
    };
    RemoteShardTelemetry: {
      /** Format: uint32 */
      shardId: number;
      /** Format: uint64 */
      peerId?: number | null;
      searches: components["schemas"]["OperationDurationStatistics"];
      updates: components["schemas"]["OperationDurationStatistics"];
    };
    CollectionsAggregatedTelemetry: {
      /** Format: uint */
      vectors: number;
      optimizersStatus: components["schemas"]["OptimizersStatus"];
      params: components["schemas"]["CollectionParams"];
    };
    ClusterTelemetry: {
      enabled: boolean;
      status?: components["schemas"]["ClusterStatusTelemetry"] | (Record<string, unknown> | null);
      config?: components["schemas"]["ClusterConfigTelemetry"] | (Record<string, unknown> | null);
    };
    ClusterStatusTelemetry: {
      /** Format: uint */
      numberOfPeers: number;
      /** Format: uint64 */
      term: number;
      /** Format: uint64 */
      commit: number;
      /** Format: uint */
      pendingOperations: number;
      role?: components["schemas"]["StateRole"] | (Record<string, unknown> | null);
      isVoter: boolean;
      /** Format: uint64 */
      peerId?: number | null;
      consensusThreadStatus: components["schemas"]["ConsensusThreadStatus"];
    };
    ClusterConfigTelemetry: {
      /** Format: uint64 */
      grpcTimeoutMs: number;
      p2p: components["schemas"]["P2pConfigTelemetry"];
      consensus: components["schemas"]["ConsensusConfigTelemetry"];
    };
    P2pConfigTelemetry: {
      /** Format: uint */
      connectionPoolSize: number;
    };
    ConsensusConfigTelemetry: {
      /** Format: uint */
      maxMessageQueueSize: number;
      /** Format: uint64 */
      tickPeriodMs: number;
      /** Format: uint64 */
      bootstrapTimeoutSec: number;
    };
    RequestsTelemetry: {
      rest: components["schemas"]["WebApiTelemetry"];
      grpc: components["schemas"]["GrpcTelemetry"];
    };
    WebApiTelemetry: {
      responses: {
        [key: string]: ({
          [key: string]: components["schemas"]["OperationDurationStatistics"] | undefined;
        }) | undefined;
      };
    };
    GrpcTelemetry: {
      responses: {
        [key: string]: components["schemas"]["OperationDurationStatistics"] | undefined;
      };
    };
    ClusterOperations: components["schemas"]["MoveShardOperation"] | components["schemas"]["ReplicateShardOperation"] | components["schemas"]["AbortTransferOperation"] | components["schemas"]["DropReplicaOperation"];
    MoveShardOperation: {
      moveShard: components["schemas"]["MoveShard"];
    };
    MoveShard: {
      /** Format: uint32 */
      shardId: number;
      /** Format: uint64 */
      toPeerId: number;
      /** Format: uint64 */
      fromPeerId: number;
    };
    ReplicateShardOperation: {
      replicateShard: components["schemas"]["MoveShard"];
    };
    AbortTransferOperation: {
      abortTransfer: components["schemas"]["MoveShard"];
    };
    DropReplicaOperation: {
      dropReplica: components["schemas"]["Replica"];
    };
    Replica: {
      /** Format: uint32 */
      shardId: number;
      /** Format: uint64 */
      peerId: number;
    };
    SearchRequestBatch: {
      searches: (components["schemas"]["SearchRequest"])[];
    };
    RecommendRequestBatch: {
      searches: (components["schemas"]["RecommendRequest"])[];
    };
    LocksOption: {
      errorMessage?: string | null;
      write: boolean;
    };
    SnapshotRecover: {
      /**
       * Format: uri 
       * @description Examples: - URL `http://localhost:8080/collections/my_collection/snapshots/my_snapshot` - Local path `file:///qdrant/snapshots/test_collection-2022-08-04-10-49-10.snapshot`
       */
      location: string;
      /**
       * @description Defines which data should be used as a source of truth if there are other replicas in the cluster. If set to `Snapshot`, the snapshot will be used as a source of truth, and the current state will be overwritten. If set to `Replica`, the current state will be used as a source of truth, and after recovery if will be synchronized with the snapshot. 
       * @default null
       */
      priority?: components["schemas"]["SnapshotPriority"] | (Record<string, unknown> | null);
    };
    /**
     * @description Defines source of truth for snapshot recovery `Snapshot` means - prefer snapshot data over the current state `Replica` means - prefer existing data over the snapshot 
     * @enum {string}
     */
    SnapshotPriority: "snapshot" | "replica";
    CollectionsAliasesResponse: {
      aliases: (components["schemas"]["AliasDescription"])[];
    };
    AliasDescription: {
      aliasName: string;
      collectionName: string;
    };
    /**
     * @description Defines write ordering guarantees for collection operations
     * 
     * * `weak` - write operations may be reordered, works faster, default
     * 
     * * `medium` - write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change
     * 
     * * `strong` - Write operations go through the permanent leader, consistent, but may be unavailable if leader is down 
     * @enum {string}
     */
    WriteOrdering: "weak" | "medium" | "strong";
    /**
     * @description Read consistency parameter
     * 
     * Defines how many replicas should be queried to get the result
     * 
     * * `N` - send N random request and return points, which present on all of them
     * 
     * * `majority` - send N/2+1 random request and return points, which present on all of them
     * 
     * * `quorum` - send requests to all nodes and return points which present on majority of them
     * 
     * * `all` - send requests to all nodes and return points which present on all of them
     * 
     * Default value is `Factor(1)`
     */
    ReadConsistency: number | components["schemas"]["ReadConsistencyType"];
    /**
     * @description * `majority` - send N/2+1 random request and return points, which present on all of them
     * 
     * * `quorum` - send requests to all nodes and return points which present on majority of nodes
     * 
     * * `all` - send requests to all nodes and return points which present on all nodes 
     * @enum {string}
     */
    ReadConsistencyType: "majority" | "quorum" | "all";
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * Collect telemetry data 
   * @description Collect telemetry data including app info, system info, collections info, cluster info, configs and statistics
   */
  telemetry: {
    parameters: {
      query: {
        /** @description If true, anonymize result */
        anonymize?: boolean;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["TelemetryData"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Collect Prometheus metrics data 
   * @description Collect metrics data including app info, collections info, cluster info and statistics
   */
  metrics: {
    parameters: {
      query: {
        /** @description If true, anonymize result */
        anonymize?: boolean;
      };
    };
    responses: {
      /** @description Metrics data in Prometheus format */
      200: {
        content: {
          "text/plain": string;
        };
      };
      /** @description error */
      "4XX": never;
    };
  };
  /**
   * Get lock options 
   * @description Get lock options. If write is locked, all write operations and collection creation are forbidden
   */
  get_locks: {
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["LocksOption"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Set lock options 
   * @description Set lock options. If write is locked, all write operations and collection creation are forbidden. Returns previous lock options
   */
  post_locks: {
    /** @description Lock options and optional error message */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LocksOption"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["LocksOption"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get cluster status info 
   * @description Get information about the current state and composition of the cluster
   */
  cluster_status: {
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["ClusterStatus"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Tries to recover current peer Raft state. */
  recover_current_peer: {
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Remove peer from the cluster 
   * @description Tries to remove peer from the cluster. Will return an error if peer has shards on it.
   */
  remove_peer: {
    parameters: {
      query: {
        /** @description If true - removes peer even if it has shards/replicas on it. */
        force?: boolean;
      };
      path: {
        /** @description Id of the peer */
        peerId: number;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * List collections 
   * @description Get list name of all existing collections
   */
  get_collections: {
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["CollectionsResponse"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Collection info 
   * @description Get detailed information about specified existing collection
   */
  get_collection: {
    parameters: {
      path: {
        /** @description Name of the collection to retrieve */
        collectionName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["CollectionInfo"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Create collection 
   * @description Create new collection with given parameters
   */
  create_collection: {
    parameters: {
      query: {
        /**
         * @description Wait for operation commit timeout in seconds. 
         * If timeout is reached - request will return with service error.
         */
        timeout?: number;
      };
      path: {
        /** @description Name of the new collection */
        collectionName: string;
      };
    };
    /** @description Parameters of a new collection */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateCollection"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Delete collection 
   * @description Drop collection and all associated data
   */
  delete_collection: {
    parameters: {
      query: {
        /**
         * @description Wait for operation commit timeout in seconds. 
         * If timeout is reached - request will return with service error.
         */
        timeout?: number;
      };
      path: {
        /** @description Name of the collection to delete */
        collectionName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Update collection parameters 
   * @description Update parameters of the existing collection
   */
  update_collection: {
    parameters: {
      query: {
        /**
         * @description Wait for operation commit timeout in seconds. 
         * If timeout is reached - request will return with service error.
         */
        timeout?: number;
      };
      path: {
        /** @description Name of the collection to update */
        collectionName: string;
      };
    };
    /** @description New parameters */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateCollection"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Update aliases of the collections */
  update_aliases: {
    parameters: {
      query: {
        /**
         * @description Wait for operation commit timeout in seconds. 
         * If timeout is reached - request will return with service error.
         */
        timeout?: number;
      };
    };
    /** @description Alias update operations */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ChangeAliasesOperation"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Create index for field in collection 
   * @description Create index for field in collection
   */
  create_field_index: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen */
        wait?: boolean;
        /** @description define ordering guarantees for the operation */
        ordering?: components["schemas"]["WriteOrdering"];
      };
      path: {
        /** @description Name of the collection */
        collectionName: string;
      };
    };
    /** @description Field name */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateFieldIndex"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["UpdateResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Delete index for field in collection 
   * @description Delete field index for collection
   */
  delete_field_index: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen */
        wait?: boolean;
        /** @description define ordering guarantees for the operation */
        ordering?: components["schemas"]["WriteOrdering"];
      };
      path: {
        /** @description Name of the collection */
        collectionName: string;
        /** @description Name of the field where to delete the index */
        fieldName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["UpdateResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Collection cluster info 
   * @description Get cluster information for a collection
   */
  collection_cluster_info: {
    parameters: {
      path: {
        /** @description Name of the collection to retrieve the cluster info for */
        collectionName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["CollectionClusterInfo"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Update collection cluster setup */
  update_collection_cluster: {
    parameters: {
      query: {
        /**
         * @description Wait for operation commit timeout in seconds. 
         * If timeout is reached - request will return with service error.
         */
        timeout?: number;
      };
      path: {
        /** @description Name of the collection on which to to apply the cluster update operation */
        collectionName: string;
      };
    };
    /** @description Collection cluster update operations */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ClusterOperations"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * List aliases for collection 
   * @description Get list of all aliases for a collection
   */
  get_collection_aliases: {
    parameters: {
      path: {
        /** @description Name of the collection */
        collectionName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["CollectionsAliasesResponse"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * List collections aliases 
   * @description Get list of all existing collections aliases
   */
  get_collections_aliases: {
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["CollectionsAliasesResponse"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Recover from an uploaded snapshot 
   * @description Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
   */
  recover_from_uploaded_snapshot: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. */
        wait?: boolean;
        /** @description Defines source of truth for snapshot recovery */
        priority?: components["schemas"]["SnapshotPriority"];
      };
      path: {
        /** @description Name of the collection */
        collectionName: string;
      };
    };
    /** @description Snapshot to recover from */
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          snapshot?: string;
        };
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description operation is accepted */
      202: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "accepted";
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Recover from a snapshot 
   * @description Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
   */
  recover_from_snapshot: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. */
        wait?: boolean;
      };
      path: {
        /** @description Name of the collection */
        collectionName: string;
      };
    };
    /** @description Snapshot to recover from */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SnapshotRecover"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description operation is accepted */
      202: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "accepted";
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * List collection snapshots 
   * @description Get list of snapshots for a collection
   */
  list_snapshots: {
    parameters: {
      path: {
        /** @description Name of the collection */
        collectionName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: (components["schemas"]["SnapshotDescription"])[];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Create collection snapshot 
   * @description Create new snapshot for a collection
   */
  create_snapshot: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. */
        wait?: boolean;
      };
      path: {
        /** @description Name of the collection for which to create a snapshot */
        collectionName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["SnapshotDescription"];
          };
        };
      };
      /** @description operation is accepted */
      202: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "accepted";
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Download collection snapshot 
   * @description Download specified snapshot from a collection as a file
   */
  get_snapshot: {
    parameters: {
      path: {
        /** @description Name of the collection */
        collectionName: string;
        /** @description Name of the snapshot to download */
        snapshotName: string;
      };
    };
    responses: {
      /** @description Snapshot file */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Delete collection snapshot 
   * @description Delete snapshot for a collection
   */
  delete_snapshot: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. */
        wait?: boolean;
      };
      path: {
        /** @description Name of the collection for which to delete a snapshot */
        collectionName: string;
        /** @description Name of the snapshot to delete */
        snapshotName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description operation is accepted */
      202: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "accepted";
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * List of storage snapshots 
   * @description Get list of snapshots of the whole storage
   */
  list_full_snapshots: {
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: (components["schemas"]["SnapshotDescription"])[];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Create storage snapshot 
   * @description Create new snapshot of the whole storage
   */
  create_full_snapshot: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. */
        wait?: boolean;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["SnapshotDescription"];
          };
        };
      };
      /** @description operation is accepted */
      202: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "accepted";
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Download storage snapshot 
   * @description Download specified snapshot of the whole storage as a file
   */
  get_full_snapshot: {
    parameters: {
      path: {
        /** @description Name of the snapshot to download */
        snapshotName: string;
      };
    };
    responses: {
      /** @description Snapshot file */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Delete storage snapshot 
   * @description Delete snapshot of the whole storage
   */
  delete_full_snapshot: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. */
        wait?: boolean;
      };
      path: {
        /** @description Name of the full snapshot to delete */
        snapshotName: string;
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: boolean;
          };
        };
      };
      /** @description operation is accepted */
      202: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "accepted";
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get point 
   * @description Retrieve full information of single point by id
   */
  get_point: {
    parameters: {
      query: {
        /** @description Define read consistency guarantees for the operation */
        consistency?: components["schemas"]["ReadConsistency"];
      };
      path: {
        /** @description Name of the collection to retrieve from */
        collectionName: string;
        /** @description Id of the point */
        id: components["schemas"]["ExtendedPointId"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["Record"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Upsert points 
   * @description Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
   */
  upsert_points: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen */
        wait?: boolean;
        /** @description define ordering guarantees for the operation */
        ordering?: components["schemas"]["WriteOrdering"];
      };
      path: {
        /** @description Name of the collection to update from */
        collectionName: string;
      };
    };
    /** @description Operation to perform on points */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PointInsertOperations"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["UpdateResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get points 
   * @description Retrieve multiple points by specified IDs
   */
  get_points: {
    parameters: {
      query: {
        /** @description Define read consistency guarantees for the operation */
        consistency?: components["schemas"]["ReadConsistency"];
      };
      path: {
        /** @description Name of the collection to retrieve from */
        collectionName: string;
      };
    };
    /** @description List of points to retrieve */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PointRequest"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: (components["schemas"]["Record"])[];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Delete points 
   * @description Delete points
   */
  delete_points: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen */
        wait?: boolean;
        /** @description define ordering guarantees for the operation */
        ordering?: components["schemas"]["WriteOrdering"];
      };
      path: {
        /** @description Name of the collection to delete from */
        collectionName: string;
      };
    };
    /** @description Operation to perform on points */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PointsSelector"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["UpdateResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Overwrite payload 
   * @description Replace full payload of points with new one
   */
  overwrite_payload: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen */
        wait?: boolean;
        /** @description define ordering guarantees for the operation */
        ordering?: components["schemas"]["WriteOrdering"];
      };
      path: {
        /** @description Name of the collection to set from */
        collectionName: string;
      };
    };
    /** @description Payload and points selector */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SetPayload"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["UpdateResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Set payload 
   * @description Set payload values for points
   */
  set_payload: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen */
        wait?: boolean;
        /** @description define ordering guarantees for the operation */
        ordering?: components["schemas"]["WriteOrdering"];
      };
      path: {
        /** @description Name of the collection to set from */
        collectionName: string;
      };
    };
    /** @description Set payload on points */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SetPayload"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["UpdateResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Delete payload 
   * @description Delete specified key payload for points
   */
  delete_payload: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen */
        wait?: boolean;
        /** @description define ordering guarantees for the operation */
        ordering?: components["schemas"]["WriteOrdering"];
      };
      path: {
        /** @description Name of the collection to delete from */
        collectionName: string;
      };
    };
    /** @description delete payload on points */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DeletePayload"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["UpdateResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Clear payload 
   * @description Remove all payload for specified points
   */
  clear_payload: {
    parameters: {
      query: {
        /** @description If true, wait for changes to actually happen */
        wait?: boolean;
        /** @description define ordering guarantees for the operation */
        ordering?: components["schemas"]["WriteOrdering"];
      };
      path: {
        /** @description Name of the collection to clear payload from */
        collectionName: string;
      };
    };
    /** @description clear payload on points */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PointsSelector"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["UpdateResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Scroll points 
   * @description Scroll request - paginate over all points which matches given filtering condition
   */
  scroll_points: {
    parameters: {
      query: {
        /** @description Define read consistency guarantees for the operation */
        consistency?: components["schemas"]["ReadConsistency"];
      };
      path: {
        /** @description Name of the collection to retrieve from */
        collectionName: string;
      };
    };
    /** @description Pagination and filter parameters */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ScrollRequest"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["ScrollResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Search points 
   * @description Retrieve closest points based on vector similarity and given filtering conditions
   */
  search_points: {
    parameters: {
      query: {
        /** @description Define read consistency guarantees for the operation */
        consistency?: components["schemas"]["ReadConsistency"];
      };
      path: {
        /** @description Name of the collection to search in */
        collectionName: string;
      };
    };
    /** @description Search request with optional filtering */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SearchRequest"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: (components["schemas"]["ScoredPoint"])[];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Search batch points 
   * @description Retrieve by batch the closest points based on vector similarity and given filtering conditions
   */
  search_batch_points: {
    parameters: {
      query: {
        /** @description Define read consistency guarantees for the operation */
        consistency?: components["schemas"]["ReadConsistency"];
      };
      path: {
        /** @description Name of the collection to search in */
        collectionName: string;
      };
    };
    /** @description Search batch request */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SearchRequestBatch"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: ((components["schemas"]["ScoredPoint"])[])[];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Recommend points 
   * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples.
   */
  recommend_points: {
    parameters: {
      query: {
        /** @description Define read consistency guarantees for the operation */
        consistency?: components["schemas"]["ReadConsistency"];
      };
      path: {
        /** @description Name of the collection to search in */
        collectionName: string;
      };
    };
    /** @description Request points based on positive and negative examples. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["RecommendRequest"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: (components["schemas"]["ScoredPoint"])[];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Recommend batch points 
   * @description Look for the points which are closer to stored positive examples and at the same time further to negative examples.
   */
  recommend_batch_points: {
    parameters: {
      query: {
        /** @description Define read consistency guarantees for the operation */
        consistency?: components["schemas"]["ReadConsistency"];
      };
      path: {
        /** @description Name of the collection to search in */
        collectionName: string;
      };
    };
    /** @description Request points based on positive and negative examples. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["RecommendRequestBatch"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: ((components["schemas"]["ScoredPoint"])[])[];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Count points 
   * @description Count points which matches given filtering condition
   */
  count_points: {
    parameters: {
      path: {
        /** @description Name of the collection to count in */
        collectionName: string;
      };
    };
    /** @description Request counts of points which matches given filtering condition */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CountRequest"];
      };
    };
    responses: {
      /** @description successful operation */
      200: {
        content: {
          "application/json": {
            /**
             * Format: float 
             * @description Time spent to process this request
             */
            time?: number;
            /** @enum {string} */
            status?: "ok";
            result?: components["schemas"]["CountResult"];
          };
        };
      };
      /** @description error */
      default: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description error */
      "4XX": {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
}

const fieldRenameMap = {"optimizerStatus":"optimizer_status","optimizer_status":"optimizerStatus","vectorsCount":"vectors_count","vectors_count":"vectorsCount","indexedVectorsCount":"indexed_vectors_count","indexed_vectors_count":"indexedVectorsCount","pointsCount":"points_count","points_count":"pointsCount","segmentsCount":"segments_count","segments_count":"segmentsCount","payloadSchema":"payload_schema","payload_schema":"payloadSchema","hnswConfig":"hnsw_config","hnsw_config":"hnswConfig","optimizerConfig":"optimizer_config","optimizer_config":"optimizerConfig","walConfig":"wal_config","wal_config":"walConfig","quantizationConfig":"quantization_config","quantization_config":"quantizationConfig","shardNumber":"shard_number","shard_number":"shardNumber","replicationFactor":"replication_factor","replication_factor":"replicationFactor","writeConsistencyFactor":"write_consistency_factor","write_consistency_factor":"writeConsistencyFactor","onDiskPayload":"on_disk_payload","on_disk_payload":"onDiskPayload","efConstruct":"ef_construct","ef_construct":"efConstruct","fullScanThreshold":"full_scan_threshold","full_scan_threshold":"fullScanThreshold","maxIndexingThreads":"max_indexing_threads","max_indexing_threads":"maxIndexingThreads","onDisk":"on_disk","on_disk":"onDisk","payloadM":"payload_m","payload_m":"payloadM","alwaysRam":"always_ram","always_ram":"alwaysRam","deletedThreshold":"deleted_threshold","deleted_threshold":"deletedThreshold","vacuumMinVectorNumber":"vacuum_min_vector_number","vacuum_min_vector_number":"vacuumMinVectorNumber","defaultSegmentNumber":"default_segment_number","default_segment_number":"defaultSegmentNumber","maxSegmentSize":"max_segment_size","max_segment_size":"maxSegmentSize","memmapThreshold":"memmap_threshold","memmap_threshold":"memmapThreshold","indexingThreshold":"indexing_threshold","indexing_threshold":"indexingThreshold","flushIntervalSec":"flush_interval_sec","flush_interval_sec":"flushIntervalSec","maxOptimizationThreads":"max_optimization_threads","max_optimization_threads":"maxOptimizationThreads","walCapacityMb":"wal_capacity_mb","wal_capacity_mb":"walCapacityMb","walSegmentsAhead":"wal_segments_ahead","wal_segments_ahead":"walSegmentsAhead","dataType":"data_type","data_type":"dataType","minTokenLen":"min_token_len","min_token_len":"minTokenLen","maxTokenLen":"max_token_len","max_token_len":"maxTokenLen","withPayload":"with_payload","with_payload":"withPayload","withVector":"with_vector","with_vector":"withVector","scoreThreshold":"score_threshold","score_threshold":"scoreThreshold","mustNot":"must_not","must_not":"mustNot","geoBoundingBox":"geo_bounding_box","geo_bounding_box":"geoBoundingBox","geoRadius":"geo_radius","geo_radius":"geoRadius","valuesCount":"values_count","values_count":"valuesCount","topLeft":"top_left","top_left":"topLeft","bottomRight":"bottom_right","bottom_right":"bottomRight","isEmpty":"is_empty","is_empty":"isEmpty","isNull":"is_null","is_null":"isNull","hasId":"has_id","has_id":"hasId","hnswEf":"hnsw_ef","hnsw_ef":"hnswEf","operationId":"operation_id","operation_id":"operationId","lookupFrom":"lookup_from","lookup_from":"lookupFrom","nextPageOffset":"next_page_offset","next_page_offset":"nextPageOffset","optimizersConfig":"optimizers_config","optimizers_config":"optimizersConfig","initFrom":"init_from","init_from":"initFrom","createAlias":"create_alias","create_alias":"createAlias","collectionName":"collection_name","collection_name":"collectionName","aliasName":"alias_name","alias_name":"aliasName","deleteAlias":"delete_alias","delete_alias":"deleteAlias","renameAlias":"rename_alias","rename_alias":"renameAlias","oldAliasName":"old_alias_name","old_alias_name":"oldAliasName","newAliasName":"new_alias_name","new_alias_name":"newAliasName","fieldName":"field_name","field_name":"fieldName","fieldSchema":"field_schema","field_schema":"fieldSchema","peerId":"peer_id","peer_id":"peerId","raftInfo":"raft_info","raft_info":"raftInfo","consensusThreadStatus":"consensus_thread_status","consensus_thread_status":"consensusThreadStatus","messageSendFailures":"message_send_failures","message_send_failures":"messageSendFailures","pendingOperations":"pending_operations","pending_operations":"pendingOperations","isVoter":"is_voter","is_voter":"isVoter","lastUpdate":"last_update","last_update":"lastUpdate","latestError":"latest_error","latest_error":"latestError","creationTime":"creation_time","creation_time":"creationTime","shardCount":"shard_count","shard_count":"shardCount","localShards":"local_shards","local_shards":"localShards","remoteShards":"remote_shards","remote_shards":"remoteShards","shardTransfers":"shard_transfers","shard_transfers":"shardTransfers","shardId":"shard_id","shard_id":"shardId","webFeature":"web_feature","web_feature":"webFeature","serviceDebugFeature":"service_debug_feature","service_debug_feature":"serviceDebugFeature","distributionVersion":"distribution_version","distribution_version":"distributionVersion","isDocker":"is_docker","is_docker":"isDocker","ramSize":"ram_size","ram_size":"ramSize","diskSize":"disk_size","disk_size":"diskSize","cpuFlags":"cpu_flags","cpu_flags":"cpuFlags","numberOfCollections":"number_of_collections","number_of_collections":"numberOfCollections","initTimeMs":"init_time_ms","init_time_ms":"initTimeMs","replicateStates":"replicate_states","replicate_states":"replicateStates","variantName":"variant_name","variant_name":"variantName","vectorIndexSearches":"vector_index_searches","vector_index_searches":"vectorIndexSearches","payloadFieldIndices":"payload_field_indices","payload_field_indices":"payloadFieldIndices","segmentType":"segment_type","segment_type":"segmentType","numVectors":"num_vectors","num_vectors":"numVectors","numPoints":"num_points","num_points":"numPoints","numDeletedVectors":"num_deleted_vectors","num_deleted_vectors":"numDeletedVectors","ramUsageBytes":"ram_usage_bytes","ram_usage_bytes":"ramUsageBytes","diskUsageBytes":"disk_usage_bytes","disk_usage_bytes":"diskUsageBytes","isAppendable":"is_appendable","is_appendable":"isAppendable","indexSchema":"index_schema","index_schema":"indexSchema","vectorData":"vector_data","vector_data":"vectorData","storageType":"storage_type","storage_type":"storageType","payloadStorageType":"payload_storage_type","payload_storage_type":"payloadStorageType","indexName":"index_name","index_name":"indexName","unfilteredPlain":"unfiltered_plain","unfiltered_plain":"unfilteredPlain","unfilteredHnsw":"unfiltered_hnsw","unfiltered_hnsw":"unfilteredHnsw","filteredPlain":"filtered_plain","filtered_plain":"filteredPlain","filteredSmallCardinality":"filtered_small_cardinality","filtered_small_cardinality":"filteredSmallCardinality","filteredLargeCardinality":"filtered_large_cardinality","filtered_large_cardinality":"filteredLargeCardinality","filteredExact":"filtered_exact","filtered_exact":"filteredExact","unfilteredExact":"unfiltered_exact","unfiltered_exact":"unfilteredExact","failCount":"fail_count","fail_count":"failCount","avgDurationMicros":"avg_duration_micros","avg_duration_micros":"avgDurationMicros","minDurationMicros":"min_duration_micros","min_duration_micros":"minDurationMicros","maxDurationMicros":"max_duration_micros","max_duration_micros":"maxDurationMicros","lastResponded":"last_responded","last_responded":"lastResponded","pointsValuesCount":"points_values_count","points_values_count":"pointsValuesCount","histogramBucketSize":"histogram_bucket_size","histogram_bucket_size":"histogramBucketSize","optimizersStatus":"optimizers_status","optimizers_status":"optimizersStatus","numberOfPeers":"number_of_peers","number_of_peers":"numberOfPeers","grpcTimeoutMs":"grpc_timeout_ms","grpc_timeout_ms":"grpcTimeoutMs","connectionPoolSize":"connection_pool_size","connection_pool_size":"connectionPoolSize","maxMessageQueueSize":"max_message_queue_size","max_message_queue_size":"maxMessageQueueSize","tickPeriodMs":"tick_period_ms","tick_period_ms":"tickPeriodMs","bootstrapTimeoutSec":"bootstrap_timeout_sec","bootstrap_timeout_sec":"bootstrapTimeoutSec","moveShard":"move_shard","move_shard":"moveShard","toPeerId":"to_peer_id","to_peer_id":"toPeerId","fromPeerId":"from_peer_id","from_peer_id":"fromPeerId","replicateShard":"replicate_shard","replicate_shard":"replicateShard","abortTransfer":"abort_transfer","abort_transfer":"abortTransfer","dropReplica":"drop_replica","drop_replica":"dropReplica","errorMessage":"error_message","error_message":"errorMessage","anonymize":"anonymize","force":"force","timeout":"timeout","wait":"wait","ordering":"ordering","priority":"priority","snapshotName":"snapshot_name","snapshot_name":"snapshotName","consistency":"consistency","id":"id"};

function isObject(value: unknown): value is Record<string, unknown> {
        return Object.prototype.toString.call(value) === '[object Object]';
}

function isPropInObject<T>(obj: T, key: PropertyKey): key is keyof T {
        return Object.prototype.hasOwnProperty.call(obj, key);
}

export function normalizeFields(source: Record<string, unknown> | unknown): Record<string, unknown> | unknown {
        if (Array.isArray(source)) {
            return source.map((value) => normalizeFields(value));
        }
        else if (isObject(source)) {
            for (const key of Object.keys(source)) {
                if (isPropInObject(fieldRenameMap, key)) {
                    const newKey = fieldRenameMap[key];
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete Object.assign(source, { [newKey]: normalizeFields(source[key]) })[key];
                }
            }
        }
        return source;
}
